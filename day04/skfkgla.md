# AOP(Aspect Oriented Programming) 면접 답변 가이드

## 1. AOP가 무엇이며, Spring에서 AOP를 어떻게 구현할 수 있는지 설명해 주세요.

**"AOP는 관점 지향 프로그래밍으로, 비즈니스 로직과 공통 관심사를 분리하는 프로그래밍 패러다임입니다."**

로깅, 보안, 트랜잭션 같은 **횡단 관심사**를 별도로 모듈화해서 코드 중복을 줄이고 유지보수성을 높이는 것을 목적으로합니다..

## AOP 구현 방법

**"Spring에서는 크게 두 가지 방식으로 구현할 수 있습니다."**

### 어노테이션 기반
**@Aspect** 어노테이션을 클래스에 붙이고, **@Before, @After, @Around** 같은 어노테이션으로 실행 시점을 정의해요. 그리고 **@Pointcut**으로 어떤 메소드에 적용할지 지정하는 방식입니다.

**AOP의 핵심 개념 세 가지**
- **Aspect**: 공통 관심사를 모듈화한 클래스
- **Pointcut**: 어디에 적용할지 정의하는 표현식
- **Advice**: 언제 실행할지 정의 (Before, After, Around 등)

**실무에서는 주로 로깅, 보안 검증, 트랜잭션 관리에 많이 사용합니다.**

## 2. AOP를 사용해 프로젝트에서 공통 로직을 처리한 사례를 설명해 주세요.


# AOP 실무 적용 경험

## 상황

이전 프로젝트에서 느린 API를 찾기 위한 성능 모니터링이 필요했는데, 모든 Controller에 일일이 성능 측정 코드를 추가하는 건 비효율적이었습니다.

## 해결방안

그래서 AOP의 @Around 어노테이션을 활용했습니다.

execution 표현식으로 모든 Controller 메소드를 대상으로 지정하고, StopWatch를 사용해서 메소드 실행 전후 시간을 측정했습니다.
특정 임계값인 15초 이상 걸리는 API는 별도 경고 로그로 남겨서 문제가 되는 API를 빠르게 식별할 수 있도록 했습니다.

## 효과

모든 API의 응답시간을 자동으로 모니터링할 수 있게 됐고, 성능 저하 API를 즉시 발견해서 빠르게 대응할 수 있었습니다.

## 확장 적용

이후에는 같은 패턴으로 API 요청/응답 로깅, 인증 검증, 예외 처리 같은 공통 기능들도 AOP로 구현했습니다.
AOP의 가장 큰 장점은 비즈니스 로직과 공통 관심사를 완전히 분리해서 코드 중복 없이 일관성 있게 적용할 수 있다는 점입니다.

## 1. RESTful API의 설계 원칙을 설명해주세요.
REST는 Representational State Transfer의 약자로, HTTP 프로토콜을 활용해서 자원을 주고받는 아키텍처 스타일입니다. 웹의 기본 기술들을 그대로 활용하기 때문에 별도의 인프라 구축이 필요 없고, HTTP의 장점을 최대한 활용할 수 있습니다.

**자원(Resource)** 은 URI로 식별하고, **행위(Verb)** 는 HTTP 메소드로, **표현(Representation)** 은 JSON이나 XML로 나타냅니다.

HTTP 메소드별로 보면 GET은 조회, POST는 생성, PUT은 전체 수정, PATCH는 부분 수정, DELETE는 삭제를 담당합니다. 특히 GET, PUT, DELETE는 멱등성을 가지고 있어서 여러 번 호출해도 결과가 동일합니다.

설계할 때는 명사형 URI를 사용하고 계층 구조를 표현합니다. 예를 들어 `/users/123/orders`처럼 사용자와 주문의 관계를 URI로 나타낼 수 있습니다.

가장 큰 장점은 클라이언트와 서버의 역할이 명확히 분리되고, 무상태성으로 인해 확장성이 좋다는 점입니다. 또한 HTTP 표준을 따르기 때문에 다양한 플랫폼에서 쉽게 사용할 수 있습니다.

## 2. 멱등성(Idempotency)이란 무엇이며, API 설계 시 이를 어떻게 고려할 수 있는지 설명해주세요.
### 개념 설명

"멱등성이란 같은 작업을 여러 번 수행해도 결과가 동일한 성질을 말합니다."
즉, API에서는 **동일한 요청을 몇 번을 보내도 서버의 상태가 동일하게 유지**되는 것을 의미해요.

### 멱등한 경우:
- `GET /users/123` - 몇 번을 호출해도 사용자 정보만 조회
- `PUT /users/123` - 사용자 정보를 특정 값으로 설정
- `DELETE /users/123` - 사용자 삭제 (이미 없어도 결과는 동일)

### 멱등하지 않은 경우:
- `POST /users` - 호출할 때마다 새 사용자 생성
- `POST /orders` - 호출할 때마다 새 주문 생성

## 멱등성이 중요한 경우 예시

네트워크는 불안하다고 했을 때, 클라이언트가 응답을 못 받으면 **재시도**를 하게 되는데, 이때 멱등성이 없으면 **중복 처리**가 발생할 수 있습니다.

예를 들어 결제 API에서 네트워크 오류로 재시도했는데 **중복 결제**가 될 수 있기 때문에 멱등성을 보장하는 것은 중요합니다.

## 실제 구현 방법

보통 PUT, DELETE, GET 같은 경우는 멱등성이 자연스레 보장이 되기 때문에 따로 처리할 필요가 없지만,
특수한 경우에는 따로 멱등성을 보장해 줘야 합니다.

### Idempotency Key 사용

가장 일반적인 방법은 **Idempotency Key**를 사용하는 거예요.

```http
POST /payments
Idempotency-Key: abc123-def456-ghi789
{
 "amount": 10000,
 "card_token": "tok_1234"
}
```
서버에서는 이 키를 체크해서 이미 처리된 요청이면 기존 결과를 반환하고, 새로운 키면 처리 후 결과를 저장해두는 방식이죠.