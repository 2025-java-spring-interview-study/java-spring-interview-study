## 1. Spring Security와 JWT 기반 인증을 설계할 때, Refresh Token은 어떤 방식으로 관리했으며, 보안적으로 주의해야 할 점은 무엇인가요?
- Refresh Token은 어떤 방식으로 관리?
  - Redis에 저장해 관리
  - TTL 설정해서 자동 만료되도록 함
  - 이상 현상 발견되면 바로 Redis에서 삭제해 무효화
- 보안적으로 주의해야 할 점은?
  - refresh token의 적절한 기간 설정
  - Refresh token의 유효기간 만료 또는 사용 시 해당 토큰으로 더 이상 토큰 재발급 못받도록 하며 보안 강화


## 2. SSE(Server-Sent Events)로 실시간 알림 기능을 구현했다고 했는데, WebSocket이 아닌 SSE를 선택한 이유는 무엇인가요?
해당 서비스에서 알림이 필요한 경우는 누군가 댓글을 달거나 특정 이벤트가 발생했을 때, 서버에서 클라이언트로 일방적으로 알려주기만 하면 되는 구조 -> websocket과 같은 양방향 통신까지는 불필요하다고 생각해서 SSE 선택


## 3. React로 풀스택 프로젝트를 개발할 때, 상태 관리(State Management)는 어떤 방식으로 처리했나요?
- React Query
  - 서버 상태를 가져오고 캐싱하는 데 사용
  - ex: 걸음 수 데이터, 캐릭터/펫 정보 등... 가져오고 캐싱
- React Context
  - 화면 간 공유해야 하는 index 값, 현재 사용자의 위치 같은 값들을 공유하기 위해 사용
  - 변경은 useReducer의 dispatch로만 처리
    -> 중간 컴포넌트들이 쓸데없이 props 전달하지 않아도 되게 함  

-> React Query와 React Context를 사용하여 서버 상태와 앱 상태가 섞이지 않게 분리함


## 4. Spring 기반으로 주문/회원관리 기능을 구현할 때, 트랜잭션 관리는 어떻게 설계했나요?
(주문 기능은 구현X로 생략!)

회원관리 기능 구현할 때, 데이터에 변경이 일어나는 작업들은 서비스 단위별로 @Transactional을 걸어서 원자성 보장
(조회는 readOnly 걸었음)

- 트랜잭션 커밋 되게 전에 DB에 저장
- 무결성 검사와 같은 핵심 데이터만 처리하도록 함
- 외부 작업(S3에 파일 올리기 등...)은 DB 커밋 후 실행  
-> DB 작업이 실패해도 외부 작업 괜히 건드려서 문제 생기지 않게 하기 위함. 반대로 외부에서 문제 생겨도 메인 트랜잭션에 영향 주지 않게 하기 위함
