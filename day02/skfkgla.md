## 1. 자바 직렬화와 역직렬화가 필요한 이유와 사용 경험은?


직렬화는 객체를 바이트 스트림으로 변환하여 저장하거나 전송할 수 있게 만드는 과정입니다. 외부에서 들어온 데이터를 다른 곳으로 보낼 때 객체를 바이트 스트림으로 변환해서 전송하기 위해 사용합니다.

**사용 경험:**
- Spring Boot에서 JSON 형식으로 직렬화하는 과정도 직렬화의 일종
- REST API 개발 시 `@RequestBody` 어노테이션 활용한 Jackson 라이브러리의 ObjectMapper를 통한 직렬화 작업 경험

---

## 2. 직렬화 작업 시 주의사항은?

1. **SerialVersionUID 관리**
    - 자동 생성되는 UID는 필드명을 기준으로 생성됨
    - 클래스 변경 시 UID가 바뀌어 역직렬화 오류 발생 가능
    - 명시적으로 SerialVersionUID 선언 권장

2. **파일 경로 처리**
    - 절대 경로 대신 상대 경로 사용 권장
    - 파일 시스템이나 패키지 구조 변경에 대응

3. **보안 정보 처리**
    - 패스워드 같은 민감 정보는 `transient` 키워드 사용
    - 평문으로 직렬화되지 않도록 관리

**꼬리질문:** Serializable 인터페이스 구현 경험은?

→  직접 구현해본 경험은 없습니다.

---

## 3. 트랜잭션에 대해 설명해주세요.

트랜잭션은 하나의 논리적 작업 단위로 데이터베이스에서 실행되는 일련의 연산입니다.

**특징:**
- 모든 연산이 성공하거나 모든 연산이 실패해야 함 (All or Nothing)

**ACID 속성:**
- **원자성(Atomicity)**: 완전 실행되거나 모두 실패
- **일관성(Consistency)**: 실행 전후 데이터 무결성 보장
- **격리성(Isolation)**: 트랜잭션들이 서로 영향을 주지 않음
- **지속성(Durability)**: 트랜잭션 결과의 영속성 보장

**실무 예시:**
계좌 이체 시 송금자 계좌 차감과 수취자 계좌 증액이 모두 성공하거나 실패해야 함

**꼬리질문:** MySQL의 기본 격리 수준은?

→ **Repeatable Read**가 MySQL의 기본 격리 수준입니다.

---

## 4. JPA에서 트랜잭션 롤백에 대해 설명해주세요.

트랜잭션 롤백은 RuntimeException 및 하위 예외 발생과 Error 발생 시에 롤백 됩니다. Checked Exception은 기본적으로 롤백되지 않지만 `rollbackFor` 속성을 사용하여 롤백 대상 예외 지정 가능합니다.

**트랜잭션 분리:**
- `REQUIRES_NEW` 옵션으로 하위 메서드의 트랜잭션을 분리 가능
- 상위/하위 트랜잭션이 독립적으로 동작

**꼬리질문:** Checked Exception 발생 시 롤백이 안 되는 이유는?

→ JPA 내부적으로 롤백 기준이 RuntimeException과 Error로 설정되어 있기 때문입니다.
트랜젝션 라이브러리의 인터셉터 패키지에 존재하는 `DefaultTransactionAttribute`의 `rollbackOn()` 메서드에서 기본값이 RuntimeException과 Error를 포함하고 있기 때문에 추가 설정이 없다면 기본값에만 롤백을 하는것으로 알고 있습니다.