--- 
### 1. Java에서 Optional 클래스가 등장한 배경과 적절한 사용법에 대해 알려주세요.
Optional은 Java 8에서 도입된 클래스이고, 가장 큰 목적은 NullPointerException을 줄이고 null 처리를 더 명시적***으로 하기 위해서입니다.
예전에는 null인지 직접 조건문으로 확인해야 했는데, Optional을 사용하면 **값이 없을 수도 있다는 걸 타입 레벨에서 표현할 수 있어서** 의도를 더 잘 드러낼 수 있어요.

저는 주로 메서드 반환값에 Optional<T>를 사용하는데요, 예를 들어 DB 조회 시 값이 없을 수도 있는 경우에 Optional.empty()를 반환하면, 호출 측에서 orElse()나 ifPresent()로 안전하게 처리할 수 있어서 좋았습니다.
다만, 파라미터나 필드로 사용하는 건 코드 복잡성이 커질 수 있어서 지양하고 있습니다.

--- 
### 2. JPA에서 N+1 문제는 어떻게 발생하며, 이를 해결하기 위한 전략은 무엇인가요?

N+1 문제는 지연 로딩(LAZY) 설정된 연관 엔티티를 반복해서 접근할 때 발생합니다.
예를 들어 게시글 목록을 가져온 다음, 각 게시글마다 작성자 이름을 출력하려 하면, 처음에 게시글 1번만 조회된 후에 각 작성자의 정보를 가져오기 위해 추가 쿼리가 N번 실행돼서 총 N+1 쿼리가 됩니다.
저는 연관 객체를 Entity로 가져오지 않고, 필요한 필드만 JPQL 또는 QueryDSL로 직접 DTO로 매핑해서 가져와 해결했습니다. 이 방법은 성능 최적화에는 유리하지만, 쿼리 복잡도가 증가합니다.

--- 
### 3. 실무에서 FetchType.LAZY를 사용할 때 주의할 점은 무엇인가요?
LAZY는 성능 최적화를 위해 기본적으로 많이 사용하는데요, 주의할 점은 영속성 컨텍스트가 닫힌 상태에서 지연 로딩 대상에 접근하면 LazyInitializationException**이 발생합니다.
실제로 저도 처음에는 컨트롤러에서 Entity를 그대로 반환해서 문제가 생긴 적이 있었습니다. 그 후에는 Service 단에서 DTO로 변환한 후에만 컨트롤러로 전달하는 구조로 바꿨습니다.
특히, 양방향 연관관계에서는 순환 참조 위험도 있어서, **DTO 분리 전략**을 사용해 필요한 필드만 전달하도록 구성했습니다.

--- 
### 4. Java 스트림 API와 루프(for-each)의 성능 차이나 장단점을 설명해 주세요.
**Stream API는 선언형으로 데이터를 처리할 수 있어서 코드가 간결하고 가독성이 좋다**는 게 가장 큰 장점입니다.
예를 들어 **필터링 → 정렬 → 매핑 같은 연산을 체이닝**으로 처리할 수 있고, **병렬 스트림을 사용하면 멀티코어 환경**에서도 효율적입니다.

반면 **for-each 루프는 좀 더 직관적이고 디버깅이 쉬운 구조**라서, 단순한 반복문에는 오히려 더 좋을 때도 있습니다.
실무에서 **복잡한 데이터 가공이 필요한 경우엔 Stream을, 로직이 단순하거나 가독성이 중요한 경우엔 for-each를 쓰는 편**입니다.

--- 
### 5. Java에서 자주 발생하는 Deadlock 문제를 발견하고 해결하기 위한 전략과 도구는 무엇이 있나요?
Deadlock은 주로 여러 스레드가 서로 자원을 점유하고, 상대방 자원을 기다리면서 락이 풀리지 않는 상황에서 발생합니다.
해결하려면 먼저** 락 획득 순서를 고정하거나, tryLock() 같은 방식으로 시간 제한을 설정**해서 대기하지 않게 하는 게 중요하다고 생각합니다.

문제 상황을 재현하거나 의심될 때는 **jstack으로 스레드 덤프를 분석
**하거나 **VisualVM, jconsole 같은 도구를 써서 어느 스레드가 멈춰 있는지 확인**했습니다.

--- 
### 6. 스레드 풀 크기는 어떻게 정해야하고, 스레드 풀에서 데드락이나 자원 경합이 발생하면 어떻게 진단하고 해결하나요?
CPU 바운드 작업: 병렬로 실행되는 CPU 연산이 많은 작업
공식: **스레드 수 ≈ CPU 코어 수 + 1**
이유: 너무 많은 스레드는 컨텍스트 스위칭 비용만 늘려 성능이 오히려 저하됩니다.

IO 바운드 작업: 네트워크/디스크 IO로 블로킹이 많은 작업.
공식: **스레드 수 ≈ CPU 코어 수 × (1 + (대기 시간 / 처리 시간))**

데드락이나 자원 경합이 발생하면 먼저 **스레드 수와 큐 길이를 조절해서 병목을 줄이고,**
**jstack, VisualVM 같은 도구로 스레드 상태나 락 점유 상태**를 추적합니다.
또, 스레드 풀에 **백프레셔(backpressure)나 타임아웃**을 걸어 문제 상황에서도 빠르게 실패하고 회복 가능한 구조 설계하는 것도 중요합니다.
